"""
Pickle2JSON is a simple Python Command Line program for converting Pickle file generated by CarMaker to JSON file that is compatible with simulator Nocturne.
Arguments: Only one (1) argument is expected which is the pickle file.  
Usage: python pickle2json.py myfile.pkl
Output: The output is a JSON file bearing the same filename containing the JSON document (compatible with Nocturne simulator and Ctrl-sim) of the converted Pickle file.
"""

# import libraries
import pickle
import json
import sys
import os
import numpy as np
from typing import Dict, Any, Optional, Iterator

ERR_VAL = -1e4
PATH = r"C:\Users\cwang76\Downloads\files_pkl"

_CARMAKER_ROAD_STR = {
    "ROAD_EDGE_MEDIAN": 'road_edge',
    "ROAD_EDGE_BOUNDARY" : 'road_edge',
    "ROAD_LINE_UNKNOWN" : 'road_line',
    "ROAD_LINE_SOLID_SINGLE_WHITE" : 'road_line',
    "ROAD_LINE_SOLID_DOUBLE_YELLOW" : 'road_line',
    "ROAD_LINE_BROKEN_SINGLE_WHITE" : 'road_line',
    "ROAD_LINE_PASSING_DOUBLE_YELLOW" : 'road_line',
    "LANE_UNDEFINED": "lane",
    "LANE_SURFACE_STREET" : 'lane',
    "LANE_FREEWAY" : 'lane',
    "LANE_UNKNOWN" : 'lane',
    "CROSSWALK" : 'crosswalk',
    "STOP_SIGN" : 'stop_sign',
    "SPEED_BUMP": 'speed_bump',
    "DRIVEWAY" : 'other'
}

_OBJECT_STR = {
    "VEHICLE" : "vehicle",
    "PEDESTRIAN" : "pedestrian"
}



def _init_tl_object(track):
    """
    Since we don't use traffic light for now, this function will return an empyt dict
    """
    returned_dict = {}

    return returned_dict

def _init_road(map_features: dict) -> Optional[Dict[str, Any]]:
    """Construct an element of map_features to a dict representing the coordinates and types
    
    Args:
        track (dict): 
    
    Returns:
        Optional[Dict[str, Any]]: dict representing the coordinates and types of road
    """

    feature_type = map_features['type']
    geometry = []
    if feature_type == "stop_sign":
        position = map_features['position']
        x = float(position[0])
        y = float(position[1])
        geometry = {'x': x, 'y': y}
    elif feature_type == 'road_line' or feature_type == 'road_edge' or feature_type == 'lane':
        polyline = map_features['polyline']
        for i in range(polyline.shape[0]):
            x = float(polyline[i][0])
            y = float(polyline[i][1])
            geometry_single = {'x': x, 'y': y}
            geometry.append(geometry_single)
    else:
        position = map_features['polygon']
        for i in range(position.shape[0]):
            x = float(position[i][0])
            y = float(position[i][1])
            geometry_single = {'x': x, 'y': y}
            geometry.append(geometry_single)
    return {
        "geometry": geometry,
        "type": feature_type
    }

def _init_object(track : dict, track_id: str) -> Optional[Dict[str, Any]]:
    """Construct a dict representing the coordinates and type of objects
    """
    states = track['state']  # dict
    position = states['position'] # ndarray
    width_list = states['width'][states['width']!=0]
    length_list = states['length'][states['length']!=0  ]
    width = float(np.min(width_list)) # float
    length = float(np.min(length_list)) # float
    heading = states['heading'] # ndarray
    velocity = states['velocity'] # ndarry
    list_position = []
    list_heading = []
    list_velocity = []
    list_valid = []
    for i in range(position.shape[0]):
        if states['valid'][i]:
            x = float(position[i][0])
            y = float(position[i][1])
            position_single = {'x': x, 'y': y}
            x_velo = float(velocity[i][0])
            y_velo = float(velocity[i][1])
            velocity_single = {'x': x_velo, 'y': y_velo}
            heading_single = float(heading[i])
            valid_single = True
        else:
            x = ERR_VAL
            y = ERR_VAL
            position_single = {'x': x, 'y': y}
            x_velo = ERR_VAL
            y_velo = ERR_VAL
            velocity_single = {'x': x_velo, 'y': y_velo}
            heading_single = ERR_VAL
            valid_single = False
        list_valid.append(valid_single)
        list_position.append(position_single)
        list_velocity.append(velocity_single)
        list_heading.append(heading_single)

    final_valid_index = 0
    for i in range(len(states['valid'])):
        if states['valid'][i]:
            final_valid_index = i
    goal_x = float(states['position'][final_valid_index][0])
    goal_y = float(states['position'][final_valid_index][1])
    goal = {'x': goal_x, 'y': goal_y}

    new_type = _OBJECT_STR[track['type']]
    num_position = len(list_position)
    num_heading = len(list_heading)
    num_velocity = len(list_velocity)
    num_valid = len(list_valid)
    # the num of position, heading, velocity and valid should be 91
    if num_position < 91:
        for i in range(91 - num_position):
            list_position.append({'x': ERR_VAL, 'y': ERR_VAL})
    elif num_position > 91:
        list_position = list_position[:91]

    if num_heading < 91:
        for i in range(91 - num_heading):
            list_heading.append(ERR_VAL)
    elif num_heading > 91:
        list_heading = list_heading[:91]

    if num_velocity < 91:
        for i in range(91 - num_velocity):
            list_velocity.append({'x': ERR_VAL, 'y': ERR_VAL})
    elif num_velocity > 91:
        list_velocity = list_velocity[:91]

    if num_valid < 91:
        for i in range(91 - num_valid):
            list_valid.append(False)
    elif num_valid > 91:
        list_valid = list_valid[:91]


    returned_dict = {
        "position": list_position,
        "velocity": list_velocity,
        "heading": list_heading,
        "length": length,
        "width": width,
        "goalPosition": goal,
        "type": new_type,
        "valid":list_valid,
        "id": track_id
    }

    return returned_dict

def pkl_to_json(scenario_path, data) -> None:
    """
    Dump a JSON file containing the information of a scenario generated by CarMaker
    """
    tl_dict = {}

    # processing of object data
    objects = []
    for track in data['tracks']:
        obj = _init_object(data['tracks'][track], track)
        if obj is not None:
            objects.append(obj)
    
    # processing of map data
    roads = []
    for feature in data['map_features']:
        road = _init_road(data['map_features'][feature])
        if road is not None:
            roads.append(road)
    
    # Construct the json file
    scenario = {
        "name": data['id'],
        "objects": objects,
        "roads": roads,
        "tl_states": tl_dict
    }
    with open(scenario_path, 'w') as f:
        json.dump(scenario, f)


if __name__ == "__main__":

    files = os.listdir(PATH)
    for e, file in enumerate(files):
        jsonfile_path = os.path.splitext(file)[0] + '.json'
        input_file = os.path.join(PATH, file)
        print(f"in iteration {e}, the inputpath is {input_file}")
        with open(input_file, 'rb') as file:
            data = pickle.load(file)

        output_dir = os.path.join(PATH, 'output')
        os.makedirs(exist_ok=True, name=output_dir)
        output_file = os.path.join(output_dir, jsonfile_path)

        # replace the type name
        for i in data['map_features']:
            old_type = data['map_features'][i]['type']
            data['map_features'][i]['type'] = _CARMAKER_ROAD_STR[old_type]
        
        pkl_to_json(output_file, data)
